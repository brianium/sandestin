#+title: Musings On Sandestin

** Goal

The goal of the sandestin library is to support effect dispatch of vector only data-structures. These data structures should be easy
to provide Malli schemas for. The library will export a single `create-dispatch` function. `create-dispatch` should be composed with
individual "registries". A "registry" will be responsible for registering one or more effects, actions, placeholders, or interceptors.

** What is a registry?

I am open to exploring alternatives, but I like the notion of a registry being a function that returns a map articulating what effects,
actions, placeholders, and interceptors are available. Different effects may have their own configuration or dependencies and functions
capture that succinctly. However, I want a registry to also provide schema data. There should should be some means to discover exactly
what types of effects a dispatch function supports. discoverability means finding a schema for the vector shape of an effect as well as a description
of what the effect is. It should be able to generate samples using the schema.

*** Potential Interface/API Surface

```clojure
(ns database.plugin
  (:require [ascolais.sandestin :as s]]))

(def ExecuteEffect
  "A malli schema for the ExecuteEffect. sandestin can own some generic schema for effect shape"
  [:tuple [:= ::execute] SqlVectorSchema NextJdbcOptsSchema s/EffectVectorSchema]])
  
;; Potential Registry function
(defn registry
  "Execute next.jdbc queries as an effect vector"
  [next-jdbc-config]
  (let [datasource-fn (make-datasource-fn next-jdbc-config)]
    {::s/effects
      {::execute
       {::s/description "Execute next.jdbc queries, dispatching a result effect on query completion"
        ::s/schema ExecuteEffect
        ::s/handler
        (fn [context system sql-vector opts result-fx]
         (let [dispatch (:dispatch context)
	       result (next.jdbc/execute! (datasource-fn) sql-vector opts)]
	   (dispatch result-fx {::result result})))}}))
```

There can likewise be `::s/actions`, `::s/placeholders`, `::s/interceptors`. The emphasis should be on attaching schemas and text descriptions that can
be discovered somehow as useful context for things like iterating using Claude Code.

** Creating a dispatch function from registries

A `create-dispatch` function should return (an ideally callable) result that can be inspected to see what is available to it.

*** Potential Interface/API Surface

#+begin_src clojure
  (ns my.app
    (:require [ascolais.sandestin :as s]
              [database.plugin :as db]))

  ;; I want dispatch to be data-oriented to start.
  ;; It takes a vector of registry vectors - i.e [registry-fn registry-dep1 registry-dep2 .... registry-depN]
  (def dispatch
    (s/create-dispatch [[db/registry {:dbtype "sqlite"}]]))

  ;; Can we make the returned result searchable somehow at the REPL?
  (s/describe dispatch ::db/execute) ;; => output description and schema for an effect by namespaced key
  (s/describe dispatch) ;; => output a sequence of all schemas and descriptions
  (s/sample dispatch ::db/execute) ;; => generate a sample effect (maybe using malli's generation facilities)
  (s/grep dispatch "<regex or glob pattern?>") => output a list matching the pattern - matches on description, key, namespace? description is priority

  ;; dispatch ALWAYS works with a vector of vectors - need a single effect? too bad, that is a vector of one effect
  (dispatch [[::db/execute ["SELECT * FROM orders"] {:builder-fn kebab}
              [:my.app/result-effect [::db/result-placeholder]]]])
#+end_src

** What is an effect(s)

An effect is a vector of the shape [::namsespaced/key & args]
Where `::namespaced/key` is the key from a registry identifying an effect or an action.

When we say "effects" we mean a vector of effect vectors.

** Influences and Context

1. Nexus as inspiration
I want nearly identical feature parity to what the Nexus library supports.
Source for this can be explored at:
/Users/brian/projects/nexus/

2. Example registry concept
This will be expanding on a registry concept I developed for datastar.wow and it's dispatch mechanism (which is built on nexus).

Source for datastar.wow can be explored at:
/Users/brian/projects/datastar.wow/

An example of a project exporting a registry to extend datastar.wow can be found at:
/Users/brian/projects/datastar.wow.deacon/

A project using this concept can be found in /Users/brian/projects/payphone/ - this project uses datastar.wow registries for domain
specific effects. The following files in that projects are relevant:
- /Users/brian/projects/payphone/src/clj/payphone/web/fx.clj (generic registry)
- /Users/brian/projects/payphone/src/clj/payphone/web/fx/personas.clj (exports a registry for a personas domain)
- /Users/brian/projects/payphone/src/clj/payphone/web/fx/stripe.clj (exports a registry for payment handling)
- /Users/brian/projects/payphone/src/clj/payphone/config.clj (see the `config` map for how the dispatch function is created for an integrant system)

** Nexus as inspiration

I really want to replicate the same vocabulary as Nexus:

*** Effects

Return value observable but not necessarily used. True side effects. Errors and results captured and observable. handler functions
receive a context map that has important information, most importantly a `dispatch` function that can be used for async dispatch with the
same configured context and system.

*** Actions

Like effects, but pure functions that return effect vectors

*** Placeholders

Functions that receive dispatch-data - mostly used to reference data that is not yet available. That data is made available through dispatch data
at dispatch time. We need this for async dispatch and for passing results from parent effects (effects that initiate some behavior) and children
(effects that are called after a parent value is resolved - like result effects in the example database plugin)

*** Interceptors

General lifecycle intstrumentation for dispatch. See how Nexus does it.

*** Differences between Sandestin and Nexus
- Sandestin makes discoverability a key feature. REPL connected LLMs should be able to easily search for what is available and be able to quickly
  understand the right tool for the job, verify correctness from the schema, and even generate sample effects.
- Sandestin does not support ClojureScript
- A stretch goal if feasible would be static discoverability tools that don't require a running REPL. Ideally fast using graal or babashka, but not
  essential for the first version.

** Permission to improve or innovate

We don't have to copy nexus if we can do it better. Dispatch systems aren't all that complex and many of them follow similar patterns. The most important
thing is that sandestin must be exceptionally useful (with strong guarantees, discoverability, and sampling through malli schemas) to LLM workflows,
particularly Claude Code.
