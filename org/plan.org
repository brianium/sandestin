#+title: Sandestin Implementation Plan
#+author: Brian & Claude
#+date: 2025-01-11

* Overview

Sandestin is an effect dispatch library for Clojure that emphasizes discoverability and schema-driven development. It draws heavy inspiration from Nexus but adds first-class support for Malli schemas, descriptions, and introspection—making it exceptionally useful for LLM-assisted workflows (particularly Claude Code with REPL connectivity).

** Goals

1. *Effect Dispatch*: Dispatch vector-only data structures representing effects
2. *Composable Registries*: Build dispatch functions from multiple registries, each providing effects, actions, placeholders, and/or interceptors
3. *Schema-Driven*: Every registered item has an associated Malli schema and description
4. *Discoverability*: REPL functions to describe, sample, and search available effects
5. *Clojure-Only*: No ClojureScript support (simplifies implementation)

** Non-Goals (Initial Version)

- Runtime validation (schemas are for discovery; validation can be added via interceptor)
- Static analysis tooling (stretch goal for later)
- ClojureScript support
- Batched effects (deferred to later version)

* Public API Surface

** Core Namespace: =ascolais.sandestin=

#+begin_src clojure
(ns ascolais.sandestin)

;; === Dispatch Creation ===

(defn create-dispatch
  "Create a dispatch function from a sequence of registries.

   Registries can be:
   - A vector [registry-fn & args] - calls (apply registry-fn args)
   - A zero-arity function - calls (registry-fn)
   - A plain map conforming to RegistrySchema

   Returns a Dispatch record that is:
   - Callable as a function: (dispatch effects) or (dispatch effects dispatch-data)
   - Inspectable via describe, sample, grep functions

   Options:
   - :system->state - fn to extract immutable state from system (for actions)"
  [registries & {:as opts}])

;; === Dispatching ===

;; The returned dispatch is callable:
;; (dispatch system dispatch-data effects)
;; (dispatch system effects) ;; empty dispatch-data
;;
;; Returns: {:results [...] :errors [...]}

;; === Discoverability ===

(defn describe
  "Describe registered items.

   (describe dispatch)              ;; all items
   (describe dispatch ::some/key)   ;; specific item by key
   (describe dispatch :effects)     ;; all effects
   (describe dispatch :actions)     ;; all actions
   (describe dispatch :placeholders) ;; all placeholders

   Returns a map or sequence of maps with:
   - ::key - the registered keyword
   - ::type - :effect, :action, or :placeholder
   - ::description - human-readable description
   - ::schema - Malli schema for the vector shape
   - ::system-keys - keys this item expects in system (if declared)
   - Plus any user-defined metadata"
  ([dispatch] ...)
  ([dispatch key-or-type] ...))

(defn sample
  "Generate sample effect/action vectors using Malli's generation.

   (sample dispatch ::db/execute)     ;; one sample
   (sample dispatch ::db/execute 5)   ;; five samples

   Returns a vector (or sequence of vectors) that conform to the schema."
  ([dispatch key] ...)
  ([dispatch key n] ...))

(defn grep
  "Search registered items by pattern.

   (grep dispatch \"database\")       ;; search descriptions
   (grep dispatch #\"execute.*\")     ;; regex on keys and descriptions

   Returns sequence of matching item descriptions (same shape as describe)."
  [dispatch pattern])

(defn schemas
  "Return a map of all schemas, useful for building composite schemas.

   (schemas dispatch)  ;; => {::db/execute [:tuple ...], ::log/info [:tuple ...]}
   "
  [dispatch])
#+end_src

** Schema Constants

#+begin_src clojure
;; Convenience schemas for common patterns

(def EffectVector
  "Schema for an effect vector that will be dispatched.
   Use in schemas where an effect accepts continuation effects."
  [:vector [:cat qualified-keyword? [:* any?]]])

(def EffectsVector
  "Schema for a vector of effect vectors (what dispatch receives)."
  [:vector EffectVector])
#+end_src

* Registry Structure

** Registry Schema

A registry is a map with the following optional keys (all namespaced under =:ascolais.sandestin=):

#+begin_src clojure
(def RegistrySchema
  [:map
   ;; Core registrations
   [::effects {:optional true}
    [:map-of :qualified-keyword EffectRegistration]]

   [::actions {:optional true}
    [:map-of :qualified-keyword ActionRegistration]]

   [::placeholders {:optional true}
    [:map-of :qualified-keyword PlaceholderRegistration]]

   [::interceptors {:optional true}
    [:vector Interceptor]]

   ;; System schema declaration (what this registry expects)
   [::system-schema {:optional true}
    [:map-of :keyword :any]]  ;; keyword -> Malli schema

   ;; State extraction (usually only one registry provides this)
   [::system->state {:optional true}
    fn?]])
#+end_src

** Effect Registration

#+begin_src clojure
(def EffectRegistration
  [:map
   [::description :string]
   [::schema :any]  ;; Malli schema for the full effect vector
   [::handler fn?]  ;; (fn [ctx system & args] ...)
   [::system-keys {:optional true} [:vector :keyword]]])  ;; declared dependencies

;; Example
{::execute
 {::description "Execute a next.jdbc query, dispatching result effects on completion"
  ::schema [:tuple
            [:= ::execute]
            SqlVectorSchema
            NextJdbcOptsSchema
            EffectVector]
  ::system-keys [:datasource]
  ::handler (fn [ctx system sql-vec opts result-fx]
              (let [{:keys [dispatch]} ctx
                    {:keys [datasource]} system
                    result (jdbc/execute! datasource sql-vec opts)]
                (dispatch result-fx {::result result})))}}
#+end_src

** Action Registration

Actions are pure functions that transform state + args into effect vectors.

#+begin_src clojure
(def ActionRegistration
  [:map
   [::description :string]
   [::schema :any]  ;; Malli schema for the action vector
   [::handler fn?]  ;; (fn [state & args] effects)
   [::system-keys {:optional true} [:vector :keyword]]])

;; Example
{::increment-counter
 {::description "Increment a counter and persist the new value"
  ::schema [:tuple [:= ::increment-counter] :int]
  ::handler (fn [state n]
              (let [new-val (+ (:counter state) n)]
                [[::db/execute
                  ["UPDATE counters SET value = ? WHERE id = 1" new-val]
                  {}
                  [::log/info "Counter updated"]]]))}}
#+end_src

** Placeholder Registration

Placeholders resolve values from dispatch-data at dispatch time.

#+begin_src clojure
(def PlaceholderRegistration
  [:map
   [::description :string]
   [::schema :any]  ;; Malli schema for the placeholder vector
   [::handler fn?]  ;; (fn [dispatch-data & args] value)
   ])

;; Example
{::result
 {::description "Access the result from a parent effect's async dispatch"
  ::schema [:tuple [:= ::result]]
  ::handler (fn [dispatch-data]
              (get dispatch-data ::result))}}

;; Placeholders can also take arguments
{::result-at
 {::description "Access a specific key from the result"
  ::schema [:tuple [:= ::result-at] :keyword]
  ::handler (fn [dispatch-data k]
              (get-in dispatch-data [::result k]))}}
#+end_src

** Interceptor Structure

#+begin_src clojure
(def Interceptor
  [:map
   [:id :qualified-keyword]
   [:before-dispatch {:optional true} fn?]  ;; (fn [ctx] ctx)
   [:after-dispatch {:optional true} fn?]
   [:before-action {:optional true} fn?]
   [:after-action {:optional true} fn?]
   [:before-effect {:optional true} fn?]
   [:after-effect {:optional true} fn?]])
#+end_src

** Registry Function Pattern

Registries with dependencies are functions that return a registry map:

#+begin_src clojure
(ns myapp.fx.database
  (:require [ascolais.sandestin :as s]))

(defn registry
  "Database effects registry.

   Requires a next.jdbc datasource-fn that returns a datasource."
  [datasource-fn]
  {::s/effects
   {::execute
    {::s/description "Execute a SQL query"
     ::s/schema [:tuple [:= ::execute] SqlVector JdbcOpts s/EffectVector]
     ::s/system-keys [:request]  ;; might need request context
     ::s/handler
     (fn [{:keys [dispatch]} system sql-vec opts result-fx]
       (let [result (jdbc/execute! (datasource-fn) sql-vec opts)]
         (when (seq result-fx)
           (dispatch result-fx {::result result}))))}}

   ::s/placeholders
   {::result
    {::s/description "The result from a database query"
     ::s/schema [:tuple [:= ::result]]
     ::s/handler (fn [dd] (::result dd))}}

   ::s/system-schema
   {:request [:maybe RingRequestSchema]}})
#+end_src

* Dispatch Mechanics

** Dispatch Flow

#+begin_src
1. INTERPOLATE placeholders in input effects
2. RUN before-dispatch interceptors
3. FOR EACH effect/action:
   a. IF action:
      - RUN before-action interceptors
      - CALL action handler with (state & args) -> new effects
      - RUN after-action interceptors
      - RECURSIVELY process returned effects
   b. IF effect:
      - RUN before-effect interceptors
      - CALL effect handler with (ctx system & args)
      - Capture result or error
      - RUN after-effect interceptors
4. RUN after-dispatch interceptors
5. RETURN {:results [...] :errors [...]}
#+end_src

** Context Map (passed to effect handlers)

#+begin_src clojure
{:dispatch      ;; fn to dispatch more effects: (dispatch effects) or (dispatch effects extra-dispatch-data)
 :dispatch-data ;; the dispatch-data map passed to dispatch
 :system        ;; the live system (also passed as second arg for convenience)
 }
#+end_src

** Dispatch Data

Dispatch data is a map passed to dispatch that:
- Is available to placeholder functions for interpolation
- Is passed through to effect handlers via context
- Can be augmented when effects call `(:dispatch ctx)` for async continuation

#+begin_src clojure
;; Initial dispatch
(dispatch system {:request ring-request} effects)

;; Effect calling async dispatch with additional data
(defn my-effect-handler [{:keys [dispatch]} system arg result-fx]
  (async/go
    (let [result (<! (fetch-something arg))]
      (dispatch result-fx {:my-ns/result result}))))
#+end_src

** Error Handling

Errors are collected as data, allowing partial success:

#+begin_src clojure
{:results
 [{:effect [::log/info "Starting"]
   :res nil}
  {:effect [::db/execute sql opts fx]
   :res [{:id 1 :name "Alice"}]}]

 :errors
 [{:phase :execute-effect
   :effect [::http/get "https://bad-url"]
   :err #error{...}}]}
#+end_src

* Interceptor Lifecycle

** Execution Order

#+begin_src
DISPATCH CALLED
│
├─ before-dispatch interceptors (in order: [a b c])
│
├─ FOR EACH action:
│  ├─ before-action interceptors
│  ├─ action handler
│  └─ after-action interceptors (reverse: [c b a])
│
├─ FOR EACH effect:
│  ├─ before-effect interceptors
│  ├─ effect handler
│  └─ after-effect interceptors (reverse)
│
└─ after-dispatch interceptors (reverse)

RETURN {:results [...] :errors [...]}
#+end_src

** Context by Phase

| Phase           | Context Keys                                              |
|-----------------+-----------------------------------------------------------|
| before-dispatch | :system :state :dispatch-data :actions :queue :stack      |
| after-dispatch  | + :results :errors                                        |
| before-action   | :state :action :errors :queue :stack                      |
| after-action    | + :actions (expanded)                                     |
| before-effect   | :system :dispatch-data :dispatch :effect :errors :results |
| after-effect    | + updated :results :errors                                |

** Example Interceptor

#+begin_src clojure
(def logging-interceptor
  {:id ::logging
   :before-dispatch
   (fn [ctx]
     (tap> {:event :dispatch-start :actions (:actions ctx)})
     ctx)
   :after-dispatch
   (fn [ctx]
     (tap> {:event :dispatch-end
            :results (:results ctx)
            :errors (:errors ctx)})
     ctx)
   :before-effect
   (fn [ctx]
     (tap> {:event :effect-start :effect (:effect ctx)})
     ctx)})
#+end_src

* Discoverability Functions

** describe

#+begin_src clojure
;; All items
(s/describe dispatch)
;; => [{::s/key ::db/execute
;;      ::s/type :effect
;;      ::s/description "Execute a SQL query"
;;      ::s/schema [:tuple ...]}
;;     ...]

;; Specific item
(s/describe dispatch ::db/execute)
;; => {::s/key ::db/execute
;;     ::s/type :effect
;;     ::s/description "Execute a SQL query"
;;     ::s/schema [:tuple [:= ::db/execute] SqlVector JdbcOpts EffectVector]
;;     ::s/system-keys [:request]
;;     :myapp/author "Brian"}  ;; user metadata preserved

;; By type
(s/describe dispatch :effects)
;; => [{...} {...}]  ;; all effects
#+end_src

** sample

#+begin_src clojure
(s/sample dispatch ::db/execute)
;; => [::db/execute ["SELECT * FROM users" 42] {:timeout 1000} [::log/info "done"]]

(s/sample dispatch ::db/execute 3)
;; => [[::db/execute ...] [::db/execute ...] [::db/execute ...]]
#+end_src

** grep

#+begin_src clojure
(s/grep dispatch "database")
;; => [{::s/key ::db/execute ::s/description "Execute a SQL query" ...}
;;     {::s/key ::db/transaction ::s/description "Run effects in database transaction" ...}]

(s/grep dispatch #"(?i)log")
;; => [{::s/key ::log/info ...} {::s/key ::log/error ...}]
#+end_src

** schemas

#+begin_src clojure
(s/schemas dispatch)
;; => {::db/execute [:tuple [:= ::db/execute] SqlVector JdbcOpts EffectVector]
;;     ::log/info [:tuple [:= ::log/info] :string]
;;     ...}

;; Useful for building composite schemas
(def MyAppEffects
  (into [:or] (vals (s/schemas dispatch))))
#+end_src

* Registry Merging

When =create-dispatch= receives multiple registries, they are merged left-to-right:

#+begin_src clojure
(s/create-dispatch
  [[db/registry datasource-fn]   ;; first
   [auth/registry jwt-secret]    ;; second
   logging/registry])            ;; third (zero-arity fn)
#+end_src

** Merge Rules

| Key              | Merge Strategy                                |
|------------------+-----------------------------------------------|
| ::effects        | merge (later overwrites earlier for same key) |
| ::actions        | merge                                         |
| ::placeholders   | merge                                         |
| ::interceptors   | into (concatenate, preserving order)          |
| ::system-schema  | merge                                         |
| ::system->state  | last wins                                     |

** Conflict Detection

When merging, if the same key appears in multiple registries:
- Log a warning (via tap>)
- Later registration wins
- Consider: optional strict mode that throws on conflict?

* Implementation Phases

** Phase 1: Core Dispatch

*Goal*: Minimal working dispatch with effects only (no actions, placeholders, interceptors)

Files:
- =src/clj/ascolais/sandestin.clj= - public API
- =src/clj/ascolais/sandestin/dispatch.clj= - dispatch implementation
- =src/clj/ascolais/sandestin/registry.clj= - registry merging

Deliverables:
- [ ] =create-dispatch= accepting registries (vector and fn forms)
- [ ] Basic effect dispatch: =(dispatch system dispatch-data effects)=
- [ ] Effect handlers receive =[ctx system & args]=
- [ ] Returns ={:results [...] :errors [...]}=
- [ ] Context includes =:dispatch= for async continuation

** Phase 2: Actions and Placeholders

*Goal*: Full Nexus vocabulary

Files:
- =src/clj/ascolais/sandestin/actions.clj= - action expansion
- =src/clj/ascolais/sandestin/placeholders.clj= - placeholder interpolation

Deliverables:
- [ ] Action handlers: =(fn [state & args] effects)=
- [ ] =::system->state= integration
- [ ] Placeholder interpolation in effect vectors
- [ ] Nested placeholder support

** Phase 3: Interceptors

*Goal*: Full lifecycle instrumentation

Files:
- =src/clj/ascolais/sandestin/interceptors.clj= - interceptor chain

Deliverables:
- [ ] Interceptor registration via =::interceptors=
- [ ] All six lifecycle phases
- [ ] Queue/stack execution model
- [ ] Error collection through interceptor chain

** Phase 4: Discoverability

*Goal*: LLM-friendly introspection

Files:
- =src/clj/ascolais/sandestin/describe.clj= - discoverability functions

Deliverables:
- [ ] =describe= function (all, by key, by type)
- [ ] =sample= function using Malli generation
- [ ] =grep= function for searching
- [ ] =schemas= function for schema access
- [ ] User metadata preservation

** Phase 5: Schema Declarations

*Goal*: System schema validation and documentation

Deliverables:
- [ ] =::system-schema= in registries
- [ ] =::system-keys= on individual effects
- [ ] Schema merging across registries
- [ ] Optional: validation interceptor

** Phase 6: Polish and Documentation

Deliverables:
- [ ] Comprehensive docstrings
- [ ] Example registries
- [ ] Error messages with helpful context
- [ ] Performance review
- [ ] README and usage guide

* Design Decisions

Resolved during planning:

1. *Batched effects*: *Deferred to later version.* Nexus supports =^:nexus/batch= for grouping multiple effects of the same type. Users can work around this by designing effects to accept vectors of items. We'll add batching support in a future version if needed.

2. *Fail-fast strategy*: *Include built-in interceptor.* Provide =ascolais.sandestin.interceptors/fail-fast= that users can add to their registries. Common need, trivial to implement, optional to use.

3. *Dispatch return type*: *Record implementing IFn.* =create-dispatch= returns a =Dispatch= record that:
   - Is callable as a function: =(dispatch system dispatch-data effects)=
   - Is inspectable: discoverability functions access registry data from the record
   - Clear structure, no magic metadata

   #+begin_src clojure
   (defrecord Dispatch [registry]
     clojure.lang.IFn
     (invoke [this system effects] ...)
     (invoke [this system dispatch-data effects] ...))
   #+end_src

4. *Async dispatch return*: *Return result map synchronously.* When an effect calls =(:dispatch ctx)=, it returns ={:results [...] :errors [...]}= immediately (dispatch is synchronous). Effect authors can inspect continuation errors or ignore the return value. Consistent with top-level dispatch behavior.

* Testing Strategy

- Unit tests for each phase
- Property-based tests using schema generators
- Integration tests with example registries
- REPL-driven development with =dev= namespace

* Dependencies

#+begin_src clojure
{:deps
 {org.clojure/clojure {:mvn/version "1.12.0"}
  metosin/malli {:mvn/version "0.16.4"}}}
#+end_src

No other runtime dependencies. Keep it minimal like Nexus.
